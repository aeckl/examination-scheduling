<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<title>Easy Read</title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body dir="ltr" bgcolor="#000000"><table align="center" width="80%"><tbody><tr><td><font size="5" color="#FFFFFF">Working with Solver Options</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">When
 you need to set options with your solver, pymprog package provides a 
global funciton solvopt(...) to do so. Actually, it does more than that:
 you can use it to set, get, or delete options, and retrieve all options
 you have set so far as a diction. This function only accepts keyword 
arguments, but can accept any “keyword=value” pair, and the meaning is 
up to the solver interface.</font></td></tr><tr><td><font size="5" color="#FFFFFF">Setting and getting options</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">Here is how you set and check your options:</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">&gt;&gt;&gt; from pymprog import *</font></td></tr><tr><td><font size="5" color="#FFFFFF">&gt;&gt;&gt; beginModel('test')</font></td></tr><tr><td><font size="5" color="#FFFFFF">&gt;&gt;&gt; solvopt(method='exact', verbosity=2)</font></td></tr><tr><td><font size="5" color="#FFFFFF">&gt;&gt;&gt; solvopt()</font></td></tr><tr><td><font size="5" color="#FFFFFF">{'verbosity': 2, 'method': 'exact'}</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">The
 sample above use the global function call to set the option method to 
‘exact’, this may mean that GLPK solver (the default solver) will solve 
the problem by the exact method. To retrieve all the options as a dict, 
simply call solvopt() without any parameter. To change one or more of 
the options, the syntax is the same as setting an option. Let’s continue
 with that python session and try this:</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">&gt;&gt;&gt; solvopt(verbosity=0)</font></td></tr><tr><td><font size="5" color="#FFFFFF">&gt;&gt;&gt; solvopt()['verbosity']</font></td></tr><tr><td><font size="5" color="#FFFFFF">0</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">Now you see that the verbosity option has been changed from 2 to 0.</font></td></tr><tr><td><font size="5" color="#FFFFFF">Deleting an option</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">To delete an option, simply set it to None. Now continue with the python session:</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">&gt;&gt;&gt; solvopt(verbosity=None)</font></td></tr><tr><td><font size="5" color="#FFFFFF">&gt;&gt;&gt; solvopt()</font></td></tr><tr><td><font size="5" color="#FFFFFF">{'method': 'exact'}</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">We saw that the verbosity option is deleted.</font></td></tr><tr><td><font size="5" color="#FFFFFF">Special options for the simplex method</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">If you use the simplex method (this is the default method) to solve your LP problem, the following options are available:</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">keywds=("msg_lev", "meth", "pricing",</font></td></tr><tr><td><font size="5" color="#FFFFFF">"r_test", "tol_bnd", "tol_dj", "tol_piv",</font></td></tr><tr><td><font size="5" color="#FFFFFF">"obj_ll", "obj_ul", "it_lim", "tm_lim",</font></td></tr><tr><td><font size="5" color="#FFFFFF">"out_frq", "out_dly", "presolve")</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">These
 options are provided via pyglpk, and unfortunately other LP methods do 
not have such options in pyglpk. The details of these options are 
explained in pyglpk documentation:</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">simplex(...): simplex([keyword arguments])</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">Attempt to solve the problem using a simplex method.</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">This procedure has a great number of optional keyword arguments</font></td></tr><tr><td><font size="5" color="#FFFFFF">to control the functioning of the solver.  We list these here,</font></td></tr><tr><td><font size="5" color="#FFFFFF">including descriptions of their legal values.</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">msg_lev : Controls the message level of terminal output.</font></td></tr><tr><td><font size="5" color="#FFFFFF">  LPX.MSG_OFF -- no output (default)</font></td></tr><tr><td><font size="5" color="#FFFFFF">  LPX.MSG_ERR -- error and warning messages</font></td></tr><tr><td><font size="5" color="#FFFFFF">  LPX.MSG_ON  -- normal output</font></td></tr><tr><td><font size="5" color="#FFFFFF">  LPX.MSG_ALL -- full informational output</font></td></tr><tr><td><font size="5" color="#FFFFFF">meth    : Simplex method option</font></td></tr><tr><td><font size="5" color="#FFFFFF">  LPX.PRIMAL  -- use two phase primal simplex (default)</font></td></tr><tr><td><font size="5" color="#FFFFFF">  LPX.DUALP   -- use two phase dual simplex, primal if that fails</font></td></tr><tr><td><font size="5" color="#FFFFFF">pricing : Pricing technique</font></td></tr><tr><td><font size="5" color="#FFFFFF">  LPX.PT_STD  -- standard textbook technique</font></td></tr><tr><td><font size="5" color="#FFFFFF">  LPX.PT_PSE  -- projected steepest edge (default)</font></td></tr><tr><td><font size="5" color="#FFFFFF">r_test  : Ratio test technique</font></td></tr><tr><td><font size="5" color="#FFFFFF">  LPX.RT_STD  -- standard textbook technique</font></td></tr><tr><td><font size="5" color="#FFFFFF">  LPX.RT_HAR  -- Harris' two-pass ratio test (default)</font></td></tr><tr><td><font size="5" color="#FFFFFF">tol_bnd : Tolerance used to check if the basic solution is primal</font></td></tr><tr><td><font size="5" color="#FFFFFF">  feasible. (default 1e-7)</font></td></tr><tr><td><font size="5" color="#FFFFFF">tol_dj  : Tolerance used to check if the basic solution is dual</font></td></tr><tr><td><font size="5" color="#FFFFFF">  feasible. (default 1e-7)</font></td></tr><tr><td><font size="5" color="#FFFFFF">tol_piv : Tolerance used to choose pivotal elements of the simplex</font></td></tr><tr><td><font size="5" color="#FFFFFF">  table. (default 1e-10)</font></td></tr><tr><td><font size="5" color="#FFFFFF">obj_ll  : Lower limit of the objective function.  The solver</font></td></tr><tr><td><font size="5" color="#FFFFFF">  terminates upon reaching this level.  This is used only in</font></td></tr><tr><td><font size="5" color="#FFFFFF">  dual simplex optimization. (default is min float)</font></td></tr><tr><td><font size="5" color="#FFFFFF">obj_ul  : Upper limit of the objective function.  The solver</font></td></tr><tr><td><font size="5" color="#FFFFFF">  terminates upon reaching this level.  This is used only in</font></td></tr><tr><td><font size="5" color="#FFFFFF">  dual simplex optimization. (default is max float)</font></td></tr><tr><td><font size="5" color="#FFFFFF">it_lim  : Simplex iteration limit. (default is max int)</font></td></tr><tr><td><font size="5" color="#FFFFFF">tm_lim  : Search time limit in milliseconds. (default is max int)</font></td></tr><tr><td><font size="5" color="#FFFFFF">out_frq : Terminal output frequency in iterations. (default 200)</font></td></tr><tr><td><font size="5" color="#FFFFFF">out_dly : Terminal output delay in milliseconds. (default 0)</font></td></tr><tr><td><font size="5" color="#FFFFFF">presolve: Use the LP presolver. (default False)</font></td></tr><tr><td><font size="5" color="#FFFFFF">  dual simplex optimization. (default is max float)</font></td></tr><tr><td><font size="5" color="#FFFFFF">it_lim  : Simplex iteration limit. (default is max int)</font></td></tr><tr><td><font size="5" color="#FFFFFF">tm_lim  : Search time limit in milliseconds. (default is max int)</font></td></tr><tr><td><font size="5" color="#FFFFFF">out_frq : Terminal output frequency in iterations. (default 200)</font></td></tr><tr><td><font size="5" color="#FFFFFF">out_dly : Terminal output delay in milliseconds. (default 0)</font></td></tr><tr><td><font size="5" color="#FFFFFF">presolve: Use the LP presolver. (default False)</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">The
 constants involved are available in pymprog as is. For example, you can
 set an option like this: solvopt(msg_lev=LPX.MSG_ERR), after you have 
imported pymprog useing “from pymprog import *” statement.</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">Note:
 if you need to warm start your simplex method (that is, start the 
simplex method with the optimal basis from your last invocation, which 
is often used when employing row generation and/or column generation), 
please don’t turn on the ‘presolve’ option. If your row/column 
generation algorithm is computation intensive and you need to write them
 in C and invoke from Python, you can consider EXPY 
(http://expy.sf.net), ctypes, SWIG (Sip for C++), and Boost.Python.</font></td></tr><tr><td><font size="5" color="#FFFFFF">Special options for the integer method</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">When
 you use the integer(...) method in pyglpk to solve your MIP problem 
(this is the default method), you may use the following options:</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">keywds=("msg_lev", "br_tech", "bt_tech",</font></td></tr><tr><td><font size="5" color="#FFFFFF">"pp_tech", "gmi_cuts", "mir_cuts",</font></td></tr><tr><td><font size="5" color="#FFFFFF">"tol_int", "tol_obj", "tm_lim", "out_frq",</font></td></tr><tr><td><font size="5" color="#FFFFFF">"out_dly", "callback")</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">Note
 that if your glpk version is too old (older than 4.24), some options 
might not be supported. Also, it seems that pyglpk does not support 
options for other MIP methods. The details of these options are 
explained in pyglpk documentation:</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">integer(...)</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">       MIP solver based on branch-and-bound.</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">       This procedure has a great number of optional keyword arguments</font></td></tr><tr><td><font size="5" color="#FFFFFF">       to control the functioning of the solver.  We list these here,</font></td></tr><tr><td><font size="5" color="#FFFFFF">       including descriptions of their legal values.</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">       msg_lev : Controls the message level of terminal output::</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">         LPX.MSG_OFF -- no output (default)</font></td></tr><tr><td><font size="5" color="#FFFFFF">         LPX.MSG_ERR -- error and warning messages</font></td></tr><tr><td><font size="5" color="#FFFFFF">         LPX.MSG_ON  -- normal output</font></td></tr><tr><td><font size="5" color="#FFFFFF">         LPX.MSG_ALL -- full informational output</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">       br_tech : Branching technique option::</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">         LPX.BR_FFV  -- first fractional variable</font></td></tr><tr><td><font size="5" color="#FFFFFF">         LPX.BR_LFV  -- last fractional variable</font></td></tr><tr><td><font size="5" color="#FFFFFF">         LPX.BR_MFV  -- most fractional variable</font></td></tr><tr><td><font size="5" color="#FFFFFF">         LPX.BR_DTH  -- heuristic by Driebeck and Tomlin (default)</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">       bt_tech : Backtracking technique option::</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">         LPX.BT_DFS  -- depth first search</font></td></tr><tr><td><font size="5" color="#FFFFFF">         LPX.BT_BFS  -- breadth first search</font></td></tr><tr><td><font size="5" color="#FFFFFF">         LPX.BT_BLB  -- best local bound (default)</font></td></tr><tr><td><font size="5" color="#FFFFFF">         LPX.BT_BPH  -- best projection heuristic</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">       pp_tech : Preprocessing technique option::</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">         LPX.PP_NONE -- disable preprocessing</font></td></tr><tr><td><font size="5" color="#FFFFFF">         LPX.PP_ROOT -- perform preprocessing only on the root level</font></td></tr><tr><td><font size="5" color="#FFFFFF">         LPX.PP_ALL  -- perform preprocessing on all levels (default)</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">       gmi_cuts: Use Gomory's mixed integer cuts (default False)</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">       mir_cuts: Use mixed integer rounding cuts (default False)</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">       tol_int : Tolerance used to check if the optimal solution to the</font></td></tr><tr><td><font size="5" color="#FFFFFF">         current LP relaxation is integer feasible.</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">       tol_obj : Tolerance used to check if the objective value in the</font></td></tr><tr><td><font size="5" color="#FFFFFF">         optimal solution to the current LP is not better than the best</font></td></tr><tr><td><font size="5" color="#FFFFFF">         known integer feasible solution.</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">       tm_lim  : Search time limit in milliseconds. (default is max int)</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">       out_frq : Terminal output frequency in milliseconds. (default 5000)</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">       out_dly : Terminal output delay in milliseconds. (default 10000)</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">       callback: A callback object the user may use to monitor and control</font></td></tr><tr><td><font size="5" color="#FFFFFF">         the solver.  During certain portions of the optimization, the</font></td></tr><tr><td><font size="5" color="#FFFFFF">         solver will call methods of callback object. (default None)</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">       The last parameter, callback, is worth its own discussion.  During</font></td></tr><tr><td><font size="5" color="#FFFFFF">       the branch-and-cut algorithm of the MIP solver, at various points</font></td></tr><tr><td><font size="5" color="#FFFFFF">       callback hooks are invoked which allow the user code to influence</font></td></tr><tr><td><font size="5" color="#FFFFFF">       the proceeding of the MIP solver.  The user code may influence the</font></td></tr><tr><td><font size="5" color="#FFFFFF">       solver in the hook by modifying and operating on a Tree instance</font></td></tr><tr><td><font size="5" color="#FFFFFF">       passed to the hook.  These hooks have various codes, which we list</font></td></tr><tr><td><font size="5" color="#FFFFFF">       here::</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">           select - request for subproblem selection</font></td></tr><tr><td><font size="5" color="#FFFFFF">           prepro - request for preprocessing</font></td></tr><tr><td><font size="5" color="#FFFFFF">           rowgen - request for row generation</font></td></tr><tr><td><font size="5" color="#FFFFFF">           heur   - request for heuristic solution</font></td></tr><tr><td><font size="5" color="#FFFFFF">           cutgen - request for cut generation</font></td></tr><tr><td><font size="5" color="#FFFFFF">           branch - request for branching</font></td></tr><tr><td><font size="5" color="#FFFFFF">           bingo  - better integer solution found</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">       During the invocation of a hook with a particular code, the</font></td></tr><tr><td><font size="5" color="#FFFFFF">       callback object will have a method of the same name as the hook</font></td></tr><tr><td><font size="5" color="#FFFFFF">       code called, with the Tree instance.  For instance, for the</font></td></tr><tr><td><font size="5" color="#FFFFFF">       'cutgen' hook, it is equivalent to: callback.cutgen(tree),</font></td></tr><tr><td><font size="5" color="#FFFFFF">       being called with tree as the Tree instance.  If the method does</font></td></tr><tr><td><font size="5" color="#FFFFFF">       not exist, then instead the method 'default' is called with the</font></td></tr><tr><td><font size="5" color="#FFFFFF">       same signature.  If neither the named hook method nor the default</font></td></tr><tr><td><font size="5" color="#FFFFFF">       method exist, then the hook is ignored.</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">The
 constants involved are available in pymprog as is. For example, you can
 set an option like this: solvopt(br_tech=LPX.BR_FFV), after you have 
imported pymprog useing “from pymprog import *” statement.</font></td></tr><tr><td><font size="5" color="#FFFFFF">Options with a model instance</font></td></tr><tr><td><font size="5" color="#FFFFFF"></font></td></tr><tr><td><font size="5" color="#FFFFFF">Options
 can be also set with a model instance, which has the same method 
solvopt(...) as the global function solvopt(...). In fact, the global 
function delegates all the work to that method of the hidden model 
instance.</font></td></tr></tbody></table></body></html>